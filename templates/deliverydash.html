<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Delivery Dash ðŸš—</title>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            background: #202020;
            font-family: 'Press Start 2P', monospace;
            color: #00ff99;
        }

        #gameWrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 160px;
        }

        canvas {
            display: block;
            background: #202020;
            border: 4px solid #30ef99;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff99;
            font-size: 20px;
        }

        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 20px;
            color: #ff4040;
            display: none;
        }

        #countdown {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 60px;
            color: #00ff99;
        }

        #controls {
            position: relative;
            margin-top: -130px;
            display: grid;
            grid-template-columns: 100px 100px 100px;
            grid-template-rows: 100px 100px;
            gap: 15px;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .btn {
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 153, 0.15);
            border: 2px solid #00ff99;
            border-radius: 50%;
            color: #00ff99;
            font-size: 26px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: 0.1s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .btn:active {
            background: rgba(0, 255, 153, 0.4);
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <!-- MUSICA DE FUNDO -->
    <audio id="bgMusic" loop muted>
        <source src="../static/audio/Helios.mp3" type="audio/mpeg">
    </audio>

    <!-- SONS DE EFEITOS -->
    <audio id="s_hit" preload="auto">
        <source src="../static/audio/hit.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_coin" preload="auto">
        <source src="../static/audio/coin.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_magnet" preload="auto">
        <source src="../static/audio/magnet.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_heart" preload="auto">
        <source src="../static/audio/heart.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_shield" preload="auto">
        <source src="../static/audio/shield.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_gameover" preload="auto">
        <source src="../static/audio/gameover.mp3" type="audio/mpeg">
    </audio>
    <audio id="s_start" preload="auto">
        <source src="../static/audio/start.mp3" type="audio/mpeg">
    </audio>

    
    <div id="hud">Velocidade: <span id="speed">0</span> | Pontos: <span id="score">0</span> | Vidas: <span
            id="lives">3</span></div>
    <div id="gameOver">ðŸš— GAME OVER ðŸš—<br><small>Pressione R para reiniciar</small></div>
    <div id="countdown"></div>

    <div id="gameWrapper">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
    </div>

    <div id="controls">
        <div></div>
        <div class="btn" data-dir="up">â–²</div>
        <div></div>
        <div class="btn" data-dir="left">â—€</div>
        <div class="btn" data-dir="down">â–¼</div>
        <div class="btn" data-dir="right">â–¶</div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';

        const speedDisplay = document.getElementById("speed");
        const scoreDisplay = document.getElementById("score");
        const livesDisplay = document.getElementById("lives");
        const gameOverEl = document.getElementById("gameOver");
        const countdownEl = document.getElementById("countdown");

        /* ---------------------------
           Ãudio de fundo & efeitos
        --------------------------- */
        const bgMusic = document.getElementById("bgMusic");
        bgMusic.volume = 0.6;

        const s_hit = document.getElementById("s_hit");
        const s_coin = document.getElementById("s_coin");
        const s_magnet = document.getElementById("s_magnet");
        const s_heart = document.getElementById("s_heart");
        const s_shield = document.getElementById("s_shield");
        const s_gameover = document.getElementById("s_gameover");
        const s_start = document.getElementById("s_start");

        // flag para saber se jÃ¡ tivemos interaÃ§Ã£o que desbloqueou Ã¡udio
        let audioUnlocked = false;

        // FunÃ§Ã£o que tenta "desbloquear" todos os Ã¡udios no primeiro gesto do usuÃ¡rio
        function unlockAllAudio() {
            if (audioUnlocked) return;
            audioUnlocked = true;

            // desmuta e tenta tocar bgMusic
            try {
                bgMusic.muted = false;
                bgMusic.play().catch(() => { /* ignorar */ });
            } catch (e) { /* ignorar */ }

            // Para desbloquear efeitos, tocamos rapidamente cada som (play -> pause).
            // Isso deve ser chamado durante uma interaÃ§Ã£o do usuÃ¡rio (evento de clique/tecla/toque).
            const effects = [s_hit, s_coin, s_magnet, s_heart, s_shield, s_gameover, s_start];
            effects.forEach(a => {
                if (!a) return;
                try {
                    // alguns navegadores permitem tocar depois de uma interaÃ§Ã£o; tocamos e pausamos.
                    a.currentTime = 0;
                    const p = a.play();
                    if (p && p.then) {
                        p.then(() => { a.pause(); a.currentTime = 0; }).catch(() => { /* bloqueado */ });
                    }
                } catch (err) { /* ignorar */ }
            });
        }

        // helper para tocar sons de forma que mÃºltiplas instÃ¢ncias possam sobrepor
        function playSound(audioEl) {
            if (!audioEl) return;
            try {
                // clonamos o elemento para permitir sobreposiÃ§Ã£o (ex.: vÃ¡rios hits seguidos)
                const cloned = audioEl.cloneNode(true);
                cloned.muted = false;
                cloned.volume = audioEl.volume ?? 1.0;
                // toca sem aguardar erro (se estiver bloqueado, falharÃ¡ silenciosamente)
                cloned.play().catch(() => { /* se bloquear, ignora */ });
            } catch (e) {
                // fallback: tentar tocar o prÃ³prio elemento (pode cortar som anterior)
                try { audioEl.play().catch(() => { }); } catch (err) { }
            }
        }

        // liga handlers para primeiro gesto do usuÃ¡rio
        function firstInteractionHandler() {
            unlockAllAudio();
            window.removeEventListener("mousedown", firstInteractionHandler);
            window.removeEventListener("touchstart", firstInteractionHandler);
            window.removeEventListener("keydown", firstInteractionHandler);
        }
        window.addEventListener("mousedown", firstInteractionHandler, { once: true });
        window.addEventListener("touchstart", firstInteractionHandler, { once: true });
        window.addEventListener("keydown", firstInteractionHandler, { once: true });

        /* ---------------------------
           VariÃ¡veis do jogo
        --------------------------- */
        let roadSpeed = 3, acceleration = 0.0002, playerSpeed = 4;
        let playerX = canvas.width / 2 - 20, playerY = canvas.height - 120;
        const roadWidth = 300, laneCount = 4, laneWidth = roadWidth / laneCount;
        let roadLines = [], keys = {}, score = 0, lives = 3;
        let obstacles = [], foods = [], magnets = [], hearts = [], shields = [], popups = [];
        let magnetActive = false, magnetTimer = 0, shieldActive = false, shieldTimer = 0;
        let gameOver = false, gameStarted = false;

        // inatividade: zerar pontuaÃ§Ã£o apÃ³s X frames
        let inactivityTimer = 0, inactivityLimit = 480;
        function punishInactivity() { score = 0; updateScoreDisplay(); createPopup("- Pontos zerados", player.x, player.y - 20); playSound(s_hit /* efeito discreto para feedback */); }

        const player = { x: playerX, y: playerY, w: 20, h: 35, color: "#00ff99" };

        const obstacleTypes = [
            { emoji: "ðŸš§", w: 30, h: 30 },
            { emoji: "ðŸ¶", w: 30, h: 30 },
            { emoji: "ðŸª¨", w: 25, h: 25 }
        ];

        // pontos reduzidos conforme seu pedido
        const foodTypes = [
            { emoji: "ðŸ”", w: 30, h: 30, points: 5 },
            { emoji: "ðŸ•", w: 30, h: 30, points: 10 }
        ];

        const magnetType = { emoji: "ðŸ§²", w: 30, h: 30 };
        const heartType = { emoji: "â¤", w: 30, h: 30 };
        const shieldType = { emoji: "ðŸ›¡", w: 30, h: 30 };
        const obstaclePenalty = 150; // penalidade ao bater em obstÃ¡culo

        /* ---------------------------
           Popups
        --------------------------- */
        function drawPopups() {
            ctx.font = "20px Arial";
            ctx.fillStyle = "#00ff99";
            for (let i = popups.length - 1; i >= 0; i--) {
                const p = popups[i];
                ctx.globalAlpha = p.alpha;
                ctx.fillText(p.text, p.x - (p.text.length * 3.5), p.y);
                p.y -= 1.2;
                p.alpha -= 0.02;
                if (p.alpha <= 0) popups.splice(i, 1);
            }
            ctx.globalAlpha = 1;
        }

        function createPopup(text, x, y) { popups.push({ text, x, y, alpha: 1 }); }

        /* ---------------------------
           Util
        --------------------------- */
        function clampScore() { if (score < 0) score = 0; }
        function updateScoreDisplay() { clampScore(); scoreDisplay.textContent = Math.floor(score); }
        function collides(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

        function safeSpawn(list, obj) {
            const allLists = [obstacles, foods, magnets, hearts, shields];
            for (let arr of allLists) for (let item of arr) if (collides(obj, item)) return false;
            list.push(obj);
            return true;
        }

        /* ---------------------------
           Spawn de objetos
        --------------------------- */
        function spawnObstacle() {
            if (Math.random() < 0.02) {
                const lane = Math.floor(Math.random() * laneCount);
                const roadX = canvas.width / 2 - roadWidth / 2;
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const obj = { ...type, x: roadX + lane * laneWidth + laneWidth / 2 - type.w / 2, y: -50 };
                safeSpawn(obstacles, obj);
            }
        }

        function spawnFood() {
            if (Math.random() < 0.015) {
                const lane = Math.floor(Math.random() * laneCount);
                const roadX = canvas.width / 2 - roadWidth / 2;
                const type = foodTypes[Math.floor(Math.random() * foodTypes.length)];
                const obj = { ...type, x: roadX + lane * laneWidth + laneWidth / 2 - type.w / 2, y: -50 };
                safeSpawn(foods, obj);
            }
        }

        function spawnMagnet() {
            if (Math.random() < 0.0002) {
                const lane = Math.floor(Math.random() * laneCount);
                const roadX = canvas.width / 2 - roadWidth / 2;
                const obj = { ...magnetType, x: roadX + lane * laneWidth + laneWidth / 2 - magnetType.w / 2, y: -50 };
                safeSpawn(magnets, obj);
            }
        }

        function spawnHeart() {
            if (Math.random() < 0.0001) {
                const lane = Math.floor(Math.random() * laneCount);
                const roadX = canvas.width / 2 - roadWidth / 2;
                const obj = { ...heartType, x: roadX + lane * laneWidth + laneWidth / 2 - heartType.w / 2, y: -50 };
                safeSpawn(hearts, obj);
            }
        }

        function spawnShield() {
            if (Math.random() < 0.0002) {
                const lane = Math.floor(Math.random() * laneCount);
                const roadX = canvas.width / 2 - roadWidth / 2;
                const obj = { ...shieldType, x: roadX + lane * laneWidth + laneWidth / 2 - shieldType.w / 2, y: -50 };
                safeSpawn(shields, obj);
            }
        }

        /* ---------------------------
           Input
        --------------------------- */
        window.addEventListener("keydown", (e) => {
            keys[e.key] = true;
            if (["ArrowLeft", "ArrowRight", "left", "right"].includes(e.key)) inactivityTimer = 0;
        });
        window.addEventListener("keyup", (e) => keys[e.key] = false);
        window.addEventListener("keydown", (e) => { if (e.key === "r" || e.key === "R") restartGame(); });

        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('touchstart', (ev) => { ev.preventDefault(); keys[btn.dataset.dir] = true; if (btn.dataset.dir === "left" || btn.dataset.dir === "right") inactivityTimer = 0; });
            btn.addEventListener('touchend', (ev) => { ev.preventDefault(); keys[btn.dataset.dir] = false; });
            btn.addEventListener('mousedown', () => { keys[btn.dataset.dir] = true; if (btn.dataset.dir === "left" || btn.dataset.dir === "right") inactivityTimer = 0; });
            btn.addEventListener('mouseup', () => { keys[btn.dataset.dir] = false; });
        });

        for (let i = 0; i < 20; i++) roadLines.push({ x: canvas.width / 2, y: i * 40 });

        /* ---------------------------
           Loop principal
        --------------------------- */
        function drawList(list) {
            ctx.font = "28px Arial";
            list.forEach(o => { ctx.fillText(o.emoji, o.x, o.y + o.h); o.y += roadSpeed; });
            return list.filter(o => o.y < canvas.height + 50);
        }

        function drawCar(p) {
            ctx.fillStyle = "#00ff99";
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = "#002200";
            ctx.fillRect(p.x + 4, p.y + 8, p.w - 8, 12);
            ctx.fillRect(p.x + 4, p.y + p.h - 20, p.w - 8, 12);
            ctx.fillStyle = "#ffff66";
            ctx.fillRect(p.x + 3, p.y, 6, 6);
            ctx.fillRect(p.x + p.w - 9, p.y, 6, 6);
            ctx.fillStyle = "#000";
            ctx.fillRect(p.x - 4, p.y + 8, 6, 15);
            ctx.fillRect(p.x + p.w - 2, p.y + 8, 6, 15);
            ctx.fillRect(p.x - 4, p.y + p.h - 25, 6, 15);
            ctx.fillRect(p.x + p.w - 2, p.y + p.h - 25, 6, 15);
            if (shieldActive) { ctx.strokeStyle = "#00aaff"; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(p.x + p.w / 2, p.y + p.h / 2, 35, 0, Math.PI * 2); ctx.stroke(); }
        }

        function checkCollision() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let o = obstacles[i];
                if (collides(player, o)) {
                    obstacles.splice(i, 1);
                    if (!shieldActive) {
                        lives--; livesDisplay.textContent = lives;
                        score -= obstaclePenalty; if (score < 0) score = 0;
                        createPopup("-" + obstaclePenalty, player.x, player.y - 20);
                        playSound(s_hit);
                        updateScoreDisplay();
                        if (lives <= 0) { gameOver = true; gameOverEl.style.display = "block"; playSound(s_gameover); }
                    } else {
                        // se shield ativo, talvez faÃ§a um som diferente (jÃ¡ tratando acima)
                        playSound(s_hit);
                    }
                }
            }
        }

        function checkFoodCollection() {
            for (let i = foods.length - 1; i >= 0; i--) {
                let f = foods[i];
                if (collides(player, f)) {
                    score += f.points;
                    createPopup("+" + f.points, f.x, f.y);
                    foods.splice(i, 1);
                    playSound(s_coin);
                    updateScoreDisplay();
                    continue;
                }
                if (magnetActive) { let dx = player.x - f.x, dy = player.y - f.y; let dist = Math.sqrt(dx * dx + dy * dy); if (dist < 150) { f.x += dx / 12; f.y += dy / 12; } }
            }
        }

        function checkMagnetCollection() { for (let i = magnets.length - 1; i >= 0; i--) if (collides(player, magnets[i])) { magnets.splice(i, 1); magnetActive = true; magnetTimer = 600; playSound(s_magnet); } }
        function checkHeartCollection() { for (let i = hearts.length - 1; i >= 0; i--) if (collides(player, hearts[i])) { hearts.splice(i, 1); lives++; livesDisplay.textContent = lives; playSound(s_heart); } }
        function checkShieldCollection() { for (let i = shields.length - 1; i >= 0; i--) if (collides(player, shields[i])) { shields.splice(i, 1); shieldActive = true; shieldTimer = 600; playSound(s_shield); } }

        function draw() {
            if (!gameStarted) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const roadX = canvas.width / 2 - roadWidth / 2;
            ctx.fillStyle = "#333"; ctx.fillRect(roadX, 0, roadWidth, canvas.height);
            ctx.fillStyle = "#888"; ctx.fillRect(roadX - 20, 0, 20, canvas.height); ctx.fillRect(roadX + roadWidth, 0, 20, canvas.height);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.setLineDash([20, 20]);
            for (let i = 1; i < laneCount; i++) { const lineX = roadX + i * laneWidth; ctx.beginPath(); ctx.moveTo(lineX, 0); ctx.lineTo(lineX, canvas.height); ctx.stroke(); }
            ctx.setLineDash([]);
            roadLines.forEach(rl => { ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(rl.x, rl.y); ctx.lineTo(rl.x, rl.y + 20); ctx.stroke(); rl.y += roadSpeed; if (rl.y > canvas.height) rl.y = -20; });

            // movimento e detecÃ§Ã£o de "moved" para inatividade
            let moved = false;
            if (keys.ArrowLeft || keys.left) { player.x -= playerSpeed; moved = true; }
            if (keys.ArrowRight || keys.right) { player.x += playerSpeed; moved = true; }
            if (keys.ArrowUp || keys.up) player.y -= playerSpeed;
            if (keys.ArrowDown || keys.down) player.y += playerSpeed;

            if (player.x < roadX) player.x = roadX; if (player.x + player.w > roadX + roadWidth) player.x = roadX + roadWidth - player.w;
            if (player.y < 0) player.y = 0; if (player.y + player.h > canvas.height) player.y = canvas.height - player.h;

            drawList(obstacles); drawList(foods); drawList(magnets); drawList(hearts); drawList(shields);
            drawCar(player); drawPopups();

            checkCollision(); checkFoodCollection(); checkMagnetCollection(); checkHeartCollection(); checkShieldCollection();

            if (magnetActive) { magnetTimer--; if (magnetTimer <= 0) magnetActive = false; }
            if (shieldActive) { shieldTimer--; if (shieldTimer <= 0) shieldActive = false; }

            roadSpeed += acceleration;
            // exibiÃ§Ã£o de velocidade simplificada
            speedDisplay.textContent = Math.floor(roadSpeed * 10);
            // bÃ´nus de pontuaÃ§Ã£o por tempo reduzido (mantive pequeno ganho)
            score += 0.01;
            updateScoreDisplay();

            spawnObstacle(); spawnFood(); spawnMagnet(); spawnHeart(); spawnShield();

            // inatividade
            if (moved) inactivityTimer = 0; else { inactivityTimer++; if (inactivityTimer >= inactivityLimit) { punishInactivity(); inactivityTimer = 0; } }

            if (!gameOver) requestAnimationFrame(draw);
        }

        function startCountdown() {
            let count = 3;
            countdownEl.textContent = count;
            const interval = setInterval(() => {
                count--;
                if (count > 0) { countdownEl.textContent = count; playSound(s_start); }
                else {
                    clearInterval(interval);
                    countdownEl.style.display = "none";
                    gameStarted = true;
                    draw();
                }
            }, 1000);
        }

        function restartGame() {
            score = 0; roadSpeed = 3; player.x = canvas.width / 2 - 20; player.y = canvas.height - 120;
            obstacles = []; foods = []; magnets = []; hearts = []; shields = []; popups = [];
            magnetActive = shieldActive = false; magnetTimer = shieldTimer = 0; lives = 3; gameOver = false;
            gameOverEl.style.display = "none"; updateScoreDisplay(); livesDisplay.textContent = lives;
            countdownEl.style.display = "block"; inactivityTimer = 0; startCountdown();
        }

        startCountdown();
    </script>

</body>

</html>